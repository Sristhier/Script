-- Rewrite Version TBD

---------------------------------------------------------------- v1.38 -----------------------------------------------------------------------------------------------------



--[[ 
+ Fixed Auto Spin
+ Added Stop at Mythicals and Legendary
+ Added Select Bosses
+ Added Leopard Fruit to Auto Skills and Auto Spin
- Removed Rumble from Auto Spin
+ Minor improvements
]]



-- Educational Anti-Cheat Bypass Script

-- Function references and variables
local getinfo = getinfo or debug.getinfo
local DEBUG = true  -- Set to true for detailed debug information
local Hooked = {}

local Detected, Kill

-- Set thread identity to bypass restrictions
setthreadidentity(2)

-- Iterate over all garbage-collected objects
for i, v in getgc(true) do
    if typeof(v) == "table" then
        local DetectFunc = rawget(v, "Detected")
        local KillFunc = rawget(v, "Kill")
        
        -- Hook the Detected function if it exists
        if typeof(DetectFunc) == "function" and not Detected then
            Detected = DetectFunc
            
            local Old; Old = hookfunction(Detected, function(Action, Info, NoCrash)
                if Action ~= "_" then
                    if DEBUG then
                        warn(string.format("Adonis AntiCheat flagged\nMethod: %s\nInfo: %s", Action, Info))
                    end
                end
                
                return true -- Neutralize the detection by returning true
            end)

            table.insert(Hooked, Detected)
        end

        -- Hook the Kill function if it exists
        if rawget(v, "Variables") and rawget(v, "Process") and typeof(KillFunc) == "function" and not Kill then
            Kill = KillFunc
            local Old; Old = hookfunction(Kill, function(Info)
                if DEBUG then
                    warn(string.format("Adonis AntiCheat tried to kill (fallback): %s", Info))
                end
                -- Prevent the Kill function from executing its anti-cheat action
            end)

            table.insert(Hooked, Kill)
        end
    end
end

-- Hook the debug.info function to interfere with detection mechanisms
local Old; Old = hookfunction(getrenv().debug.info, newcclosure(function(...)
    local LevelOrFunc, Info = ...

    if Detected and LevelOrFunc == Detected then
        if DEBUG then
            warn("discord.gg/nZcyQ7KWwZ | adonis bypassed")
        end

        return coroutine.yield(coroutine.running()) -- Interfere with the anti-cheat detection
    end
    
    return Old(...)
end))

-- Reset thread identity to ensure it runs with the necessary permissions
setthreadidentity(7)

-- Optional: Additional safety and cleanup
if DEBUG then
    warn("Anti-cheat bypass script executed successfully. Hooks installed:")
    for _, func in ipairs(Hooked) do
        warn(tostring(func))
    end
end



if not game:IsLoaded() then 
    repeat game.Loaded:Wait()
    until game:IsLoaded() 
end


local FolderName = "Kaos Hub Configs"
local FileName = FolderName.."\\FruitBattlegrounds.json"

local http = game:GetService("HttpService")
local function jsone(str) return http:JSONEncode(str) end
local function jsond(str) return http:JSONDecode(str) end

local configs = {
   ["FarmAllPlayers"] = false,
   ["SkillFruit"] = nil,
   ["AutoSkill"] = false,
   ["AutoAttack"] = false,
   ["NoStun"] = false,
   ["NoBurn"] = false,
   ["NoCd"] = false,
   ["XpFarm"] = false,
   ["Webhook"] = nil,
   ["ESPBox"] = false,
   ["ESPBoxOutline"] = false,
   ["ESPHealthBar"] = false,
   ["ESPNames"] = false,
   ["ESPNamesOutline"] = false,
   ["NoClip"] = false,
   ["InfiniteJump"] = false,
   ["SafeZoneGod"] = false,
   ["WalkSpeedEnabled"] = false,
   ["SafeMode"] = false,
   ["AutoFarm"] = false,
   ["SelectedBoss"] = nil,
   ["SelectedMob"] = nil,
   ["DistanceAutoFarm"] = 7,
   ["Method"] = nil,
   ["AutoRespawn"] = false,
}

local cachedconfigs = isfolder(FolderName) and isfile(FileName) and jsond(readfile(FileName))

if cachedconfigs then
   for i,v in next, configs do
       if cachedconfigs[i] == nil then
           warn("Missing: ",i," Now being set to: ",v)
           cachedconfigs[i] = v
       end
   end
   configs = cachedconfigs
   writefile(FileName,jsone(configs))
end

if not isfolder(FolderName) then
   warn(FolderName," not found")
   makefolder(FolderName)
end

if not isfile(FileName) then
   warn(FileName," not found")
   writefile(FileName,jsone(configs))
end

print(configs)
print(jsone(configs))
print("\n")
for i,v in next, configs do
   print(i,v)
end


for i, v in next, getconnections(game:GetService("Players").LocalPlayer.Idled) do
    v:Disable();
end;


getgenv().rejoin = game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
    if child.Name == 'ErrorPrompt' and child:FindFirstChild('MessageArea') and child.MessageArea:FindFirstChild("ErrorFrame") then
        game:GetService("TeleportService"):Teleport(game.PlaceId)
    end
 end)


 


_G.enabled = true
_G.kick = false -- instant kick if mod detected
_G.notify = true -- notify if mod detected

local groups = {
    14453089 -- example group IDs, you can remove if you want
}

-- will detect 99% of mod roles
local defaultRoles = {'mod', 'admin', 'support', 'manager', 'staff', 'dev'}

local customRoles = {'dev 2', 'contributor', "swag kids", 'second', 'owner'} -- add custom roles in here, THE ROLE MUST BE IN LOWER CASE. e.g. 'admin' or '[5] admin'
local players = game:GetService('Players')
local localplayer = players.LocalPlayer
local sent = false

function getMods()
    for i, v in next, players:GetPlayers() do
        for _, group in next, groups do
            if v and v ~= localplayer then
                local role = v:GetRoleInGroup(group):lower()
                for _, defRole in next, defaultRoles do
                    if string.match(role, defRole) or table.find(customRoles, role) then
                        return true, role, group
                    end
                end
            end
        end
        return false
    end
end

function detectMods()
    local detected, role, group = getMods()

    if detected and _G.kick then
        localplayer:Kick('[Kaos Hub] A blacklisted role has been detected in your game! Role name: ' .. role .. ' | Group ID: ' .. group)

    elseif detected and _G.notify and not sent then
        local function callbackkick() localplayer:Kick() end
        local bindable = Instance.new("BindableFunction")
        bindable.OnInvoke = callbackkick

        game.StarterGui:SetCore("SendNotification", {
            Title = '[Kaos Hub]',
            Text = 'A blacklisted role has been detected in your game! Role name: ' .. role .. ' | Group ID: ' .. group,
            Duration = 12,
            Button1 = 'Click me to leave game',
            Callback = bindable
        })
        if not sent then sent = true else sent = false end
    end
end
detectMods()

players.PlayerAdded:Connect(function()
    detectMods()
end)
 

-- Services & Universal Stuff 

 
local _Flight = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	    local character = Player.Character
	local camera = workspace.CurrentCamera
	
	local module = {}
	module.Options = {
		Speed = 5,
		Smoothness = 0.2,
	}
	
	local lib, connections = {}, {}
	lib.connect = function(name, connection)
		connections[name .. tostring(math.random(1000000, 9999999))] = connection
		return connection
	end
	lib.disconnect = function(name)
		for title, connection in pairs(connections) do
			if title:find(name) == 1 then
				connection:Disconnect()
			end
		end
	end
	
	--// Functions
	local flyPart
	
	local function flyEnd()
		lib.disconnect("fly")
		if flyPart then
			--flyPart:Destroy()
		end
		character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
		if character and character.Parent and flyPart then
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Velocity = Vector3.new()
				end
			end
		end
	end
	
	module.flyStart = function(enabled)
		if not enabled then flyEnd() return end
		local dir = {w = false, a = false, s = false, d = false}
		local cf = Instance.new("CFrameValue")
		
		flyPart = flyPart or Instance.new("Part")
		flyPart.Anchored = true
		pcall(function()
			flyPart.CFrame = character.HumanoidRootPart.CFrame
		end)
		
		lib.connect("fly", RunService.Heartbeat:Connect(function()
			if not character or not character.Parent or not character:FindFirstChild("HumanoidRootPart") then return end
	
			local primaryPart = character.HumanoidRootPart
			local humanoid = character:FindFirstChildWhichIsA("Humanoid")
			local speed = module.Options.Speed
			
			local x, y, z = 0, 0, 0
			if dir.w then z = -1 * speed end
			if dir.a then x = -1 * speed end
			if dir.s then z = 1 * speed end
			if dir.d then x = 1 * speed end
			if dir.q then y = 1 * speed end
			if dir.e then y = -1 * speed end
			
			flyPart.CFrame = CFrame.new(
				flyPart.CFrame.p,
				(camera.CFrame * CFrame.new(0, 0, -2048)).p
			)
			
			for _, part in pairs(character:GetChildren()) do
				if part:IsA("BasePart") then
					part.Velocity = Vector3.new()
				end
			end
			
			local moveDir = CFrame.new(x,y,z)
			cf.Value = cf.Value:lerp(moveDir, module.Options.Smoothness)
			flyPart.CFrame = flyPart.CFrame:lerp(flyPart.CFrame * cf.Value, module.Options.Smoothness)
			primaryPart.CFrame = flyPart.CFrame
			humanoid.PlatformStand = true
		end))
		lib.connect("fly", UserInputService.InputBegan:Connect(function(input, event)
			if event then return end
			local code, codes = input.KeyCode, Enum.KeyCode
			if code == codes.W then
				dir.w = true
			elseif code == codes.A then
				dir.a = true
			elseif code == codes.S then
				dir.s = true
			elseif code == codes.D then
				dir.d = true
			elseif code == codes.Q then
				dir.q = true
			elseif code == codes.E then
				dir.e = true
			elseif code == codes.Space then
				dir.q = true
			end
		end))
		lib.connect("fly", UserInputService.InputEnded:Connect(function(input, event)
			if event then return end
			local code, codes = input.KeyCode, Enum.KeyCode
			if code == codes.W then
				dir.w = false
			elseif code == codes.A then
				dir.a = false
			elseif code == codes.S then
				dir.s = false
			elseif code == codes.D then
				dir.d = false
			elseif code == codes.Q then
				dir.q = false
			elseif code == codes.E then
				dir.e = false
			elseif code == codes.Space then
				dir.q = false
			end
		end))
	end
	
	--// Events
	Player.CharacterAdded:Connect(function(char)
		character = char
	end)
	
	return module
end)()


local _ESP = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	local Screen = Instance.new("ScreenGui")
	  local Viewport = Instance.new("ViewportFrame", Screen)
	
	local module = {}
	local characters = {}
	local clones = {}
	local parts = {}
	
	module.Options = {
		Enabled = false,
		Parent = script.Parent or game.CoreGui,
		Color = Color3.new(1, 1, 1),
		ShowDescendants = false,
		TeamColor = false,
		ShowSelf = false,
		ShowTeam = false,
		Mode = "Shader",
		Opacity = 1,
		Arrow = false,
		MaxDistance = 500,
	}
	
	--// Edits
	Viewport.Size = UDim2.new(1, 0, 1, 0)
	Viewport.BackgroundTransparency = 1
	Viewport.CurrentCamera = workspace.CurrentCamera
	Screen.IgnoreGuiInset = true
	
	--// Functions
	local function getParts(Model)
		local parts = {}
		local descendants = Model:GetDescendants()
		local descendantsn = #descendants
		for i = 1, descendantsn do
			local desc = descendants[i]
			if desc:IsA("BasePart") then
				table.insert(parts, desc)
			end
		end
		return parts
	end
	
	local function getPart(Model)
		return Model.PrimaryPart or Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChildWhichIsA("Part")
	end
	
	function module:Clone(Object)
		local isArchivable = Object.Archivable
		local Clone
		
		Object.Archivable = true
		Clone = Object:Clone()
		Object.Archivable = isArchivable
		
		for _, child in pairs(Clone:GetDescendants()) do
			if child:IsA("Clothing") or child:IsA("Decal") or child:IsA("Script") or child:IsA("LocalScript") or child:IsA("Sound") then
				child:Destroy()
			elseif child:IsA("BasePart") then
				child.Color = Color3.new(1, 1, 1)
				child.Material = "ForceField"
			elseif child:IsA("Humanoid") then
				child.DisplayDistanceType = "None"
			elseif child:IsA("SpecialMesh") then
				child.TextureId = "rbxassetid://55054494"
			elseif child:IsA("MeshPart") then
				child.TextureID = "rbxassetid://55054494"
			end
		end
		
		return Clone
	end
	
	function module:Enable()
		module.Options.Enabled = true
		Screen.Parent = module.Options.Parent
		
		module:ReloadCharacters()
	end
	
	function module:Disable()
		module.Options.Enabled = false
		Screen.Parent = nil
	end
	
	function module:ReloadCharacters()
		Viewport:ClearAllChildren()
		if module.Options.Mode ~= "Shader" then
			return
		end
		for player, character in pairs(characters) do
			local clone = module:Clone(character)
			clone.Name = player.Name
			clone.Parent = Viewport
			clones[player] = clone
		end
	end
	
	local function newPlayer(player)
		if player.Character then
			characters[player] = player.Character
			
			local clone = module:Clone(player.Character)
			clone.Name = player.Name
			clone.Parent = Viewport
			clones[player] = clone
		end
		player.CharacterAdded:Connect(function(char)
			if clones[player] then
				clones[player]:Destroy()
				clones[player] = nil
			end;if characters[player] then
				characters[player]:Destroy()
				characters[player] = nil
			end
			
			characters[player] = char
			
			local clone = module:Clone(char)
			clone.Name = player.Name
			clone.Parent = Viewport
			clones[player] = clone
		end)
	end
	
	Players.PlayerAdded:Connect(newPlayer)
	Players.PlayerRemoving:Connect(function(player)
		if clones[player] then
			clones[player]:Destroy()
			clones[player] = nil
		end;if characters[player] then
			characters[player]:Destroy()
			characters[player] = nil
		end
	end)
	for _, player in pairs(Players:GetPlayers()) do
		newPlayer(player)
	end
	
	
	return module
	
end)()
local _Chams = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	local Screen = Instance.new("ScreenGui")
	  local Viewport = Instance.new("ViewportFrame", Screen)
	
	local module = {}
	local characters = {}
	local clones = {}
	local parts = {}
	
	module.Options = {
		Enabled = false,
		Parent = script.Parent or game.CoreGui,
		Color = Color3.new(1, 1, 1),
		ShowDescendants = false,
		TeamColor = false,
		ShowSelf = false,
		ShowTeam = false,
		Mode = "Shader",
		Opacity = 1,
		MaxDistance = 500,
	}
	
	--// Edits
	Viewport.Size = UDim2.new(1, 0, 1, 0)
	Viewport.BackgroundTransparency = 1
	Viewport.CurrentCamera = workspace.CurrentCamera
	Screen.IgnoreGuiInset = true
	
	--// Functions
	local function getParts(Model)
		local parts = {}
		local descendants = Model:GetDescendants()
		local descendantsn = #descendants
		for i = 1, descendantsn do
			local desc = descendants[i]
			if desc:IsA("BasePart") then
				table.insert(parts, desc)
			end
		end
		return parts
	end
	
	local function getPart(Model)
		return Model.PrimaryPart or Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChildWhichIsA("Part")
	end
	
	function module:Clone(Object)
		local isArchivable = Object.Archivable
		local Clone
		
		Object.Archivable = true
		Clone = Object:Clone()
		Object.Archivable = isArchivable
		
		if module.Options.Mode == "Shader" then
			Viewport.Ambient = Color3.fromRGB(200, 200, 200)
		else
			Viewport.Ambient = Color3.fromRGB(255, 255, 255)
		end
		
		for _, child in pairs(Clone:GetDescendants()) do
			if child:IsA("Script") or child:IsA("LocalScript") or child:IsA("Sound") then
				child:Destroy()
			elseif child:IsA("Humanoid") then
				child.DisplayDistanceType = "None"
			elseif module.Options.Mode ~= "Shader" then
				if child:IsA("SpecialMesh") then
					child.TextureId = ""
				elseif child:IsA("MeshPart") then
					child.TextureID = ""
				elseif child:IsA("BasePart") then
					child.Color = Color3.new(1, 1, 1)
					child.Material = "Neon"
				elseif child:IsA("Clothing") or child:IsA("Decal") then
					child:Destroy()
				end
			end
		end
		
		return Clone
	end
	
	function module:Enable()
		module.Options.Enabled = true
		Screen.Parent = module.Options.Parent
		
		module:ReloadCharacters()
	end
	
	function module:Disable()
		module.Options.Enabled = false
		Screen.Parent = nil
	end
	
	function module:ReloadCharacters()
		Viewport:ClearAllChildren()
		for player, character in pairs(characters) do
			local clone = module:Clone(character)
			clone.Name = player.Name
			clone.Parent = Viewport
			clones[player] = clone
		end
	end
	
	local function newPlayer(player)
		if player.Character then
			characters[player] = player.Character
			
			local clone = module:Clone(player.Character)
			clone.Name = player.Name
			clone.Parent = Viewport
			clones[player] = clone
		end
		player.CharacterAdded:Connect(function(char)
			if clones[player] then
				clones[player]:Destroy()
				clones[player] = nil
			end;if characters[player] then
				characters[player]:Destroy()
				characters[player] = nil
			end
			
			characters[player] = char
			
			local clone = module:Clone(char)
			clone.Name = player.Name
			clone.Parent = Viewport
			clones[player] = clone
		end)
	end
	
	Players.PlayerAdded:Connect(newPlayer)
	Players.PlayerRemoving:Connect(function(player)
		if clones[player] then
			clones[player]:Destroy()
			clones[player] = nil
		end;if characters[player] then
			characters[player]:Destroy()
			characters[player] = nil
		end
	end)
	for _, player in pairs(Players:GetPlayers()) do
		newPlayer(player)
	end
	
	RunService.RenderStepped:Connect(function()
		if module.Options.Enabled then
			for player, character in pairs(characters) do
				local clone = clones[player]
				local target = getPart(clone)
				
				if target then
					if ((player.Team == Player.Team and module.Options.ShowTeam) or player.Team ~= Player.Team) and target and (target.Position - workspace.CurrentCamera.CFrame.p).Magnitude <= module.Options.MaxDistance then
						if (player == Player and module.Options.ShowSelf) or player ~= Player then
							local parts = getParts(clone)
							for i = 1, #parts do
								local obj = parts[i]
								local cor = character:FindFirstChild(obj.Name, true)
								if character:FindFirstChild(obj.Parent.Name) then
									cor = character:FindFirstChild(obj.Parent.Name):FindFirstChild(obj.Name)
								end
								
								if cor and obj then
									if module.Options.TeamColor then
										obj.Color = player.TeamColor.Color
									elseif module.Options.Mode ~= "Shader" then
										obj.Color = Color3.new(1, 1, 1)
									end
									if module.Options.ShowDescendants then
										obj.CFrame = cor.CFrame
									elseif obj.Parent == clone then
										obj.CFrame = cor.CFrame
									else
										obj.CFrame = CFrame.new(10000, 10000, 10000)
									end
								end
							end
							if clone.Parent == nil then
								clone.Parent = Viewport
							end
						else
							clone.Parent = nil
						end
					else
						clone.Parent = nil
					end
				else
					clone.Parent = nil
				end
			end
			Viewport.ImageColor3 = module.Options.Color
			Viewport.ImageTransparency = 1 - module.Options.Opacity
		end
	end)
	
	return module
	
end)()
local _Tracers = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	local Screen = Instance.new("ScreenGui")
	local Camera = workspace.CurrentCamera
	
	local module = {}
	local characters = {}
	local tracers = {}
	
	module.Options = {
		Enabled = false,
		Parent = script.Parent or game.CoreGui,
		Color = Color3.new(1, 1, 1),
		TeamColor = false,
		ShowSelf = false,
		ShowTeam = false,
		Opacity = 1,
		Radius = 1,
		MaxDistance = 500,
	}
	
	Screen.Parent = module.Options.Parent
	Screen.IgnoreGuiInset = true
	
	--// Functions
	local function getParts(Model)
		local parts = {}
		local descendants = Model:GetDescendants()
		local descendantsn = #descendants
		for i = 1, descendantsn do
			local desc = descendants[i]
			if desc:IsA("BasePart") then
				table.insert(parts, desc)
			end
		end
		return parts
	end
	
	local function getPart(Model)
		return Model.PrimaryPart or Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChildWhichIsA("Part")
	end
	
	function module:Enable()
		module.Options.Enabled = true
		module:ReloadCharacters()
	end
	
	function module:Disable()
		module.Options.Enabled = false
		for plr, line in pairs(tracers) do
			if line then
				line[1]:Destroy()
			end
			tracers[plr] = nil
		end
	end
	
	function module:LoadCharacter(player, char)
		local tracer = {}
		local target = getPart(char)
		if target then
			local line = Instance.new("Part", Screen)
			line.Transparency = 1
			line.Anchored = true
			line.CanCollide = false
			
			local adornment = Instance.new("LineHandleAdornment", line)
			adornment.Name = "A"
			adornment.AlwaysOnTop = true
			adornment.ZIndex = 1
			adornment.Adornee = line
			
			tracer[1] = line
			tracer[2] = target
			tracer[3] = player
		else
			return
		end
		
		tracers[player] = tracer
	end
	
	function module:ReloadCharacters()
		for plr, line in pairs(tracers) do
			if line then
				line[1]:Destroy()
			end
			tracers[plr] = nil
		end
		if module.Options.Enabled then
			for player, character in pairs(characters) do
				if (player.Team == Player.Team and module.Options.ShowTeam) or player.Team ~= Player.Team then
					if (player == Player and module.Options.ShowSelf) or player ~= Player then
						module:LoadCharacter(player, character)
					end
				end
			end
		end
	end
	
	local function newPlayer(player)
		if player.Character then
			characters[player] = player.Character
			module:LoadCharacter(player, player.Character)
		end
		player.CharacterAdded:Connect(function(char)
			if tracers[player] then
				tracers[player][1]:Destroy()
				tracers[player] = nil
			end
			char:WaitForChild("Humanoid")
			characters[player] = char
			module:LoadCharacter(player, player.Character)
		end)
	end
	
	Players.PlayerAdded:Connect(newPlayer)
	Players.PlayerRemoving:Connect(function(player)
		if tracers[player] then
			if tracers[player] then
				tracers[player][1]:Destroy()
				tracers[player] = nil
			end
			characters[player] = nil
		end
	end)
	for _, player in pairs(Players:GetPlayers()) do
		newPlayer(player)
	end
	
	local function divideUDim(udim, factor)
		return UDim2.new(udim.X.Scale / factor, udim.X.Offset / factor, udim.Y.Scale / factor, udim.Y.Offset / factor)
	end
	
	RunService.RenderStepped:Connect(function()
		if module.Options.Enabled then
			for player, data in pairs(tracers) do
				local line, target = unpack(data)
				if (target and (player.Team == Player.Team and module.Options.ShowTeam) or player.Team ~= Player.Team) and (target.Position - Camera.CFrame.p).Magnitude <= module.Options.MaxDistance then
					if (player == Player and module.Options.ShowSelf) or player ~= Player then
						if line.Parent ~= Screen then
							line.Parent = Screen
						end
						
						local point1 = (Camera.CFrame * CFrame.new(0, 0, -0.5) - Vector3.new(0, 3, 0)).p
						local point2 = target.Position - Vector3.new(0, 3, 0)
						
						local distance = point1 - point2
						local magnitude = distance.Magnitude
						
						local c = module.Options.Color
						
						line.CFrame = CFrame.new(point1, point2)
						
						line.A.Thickness = module.Options.Radius
						line.A.Length = magnitude
						line.A.Color3 = Color3.new(c.r*5,c.g*5,c.b*5)
						line.A.Transparency = 1 - module.Options.Opacity
					else
						line.Parent = nil
					end
				else
					line.Parent = nil
				end
			end
		end
	end)
	
	spawn(function()
		while wait(2) do
			if module.Options.Enabled then
				module:ReloadCharacters()
			end
		end
	end)
	
	return module
	
end)()

local _Freecam = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	    local character = Player.Character
	local camera = workspace.CurrentCamera
	
	local module = {}
	module.Options = {
		Speed = 5,
		Smoothness = 0.2,
	}
	
	local lib, connections = {}, {}
	lib.connect = function(name, connection)
		connections[name .. tostring(math.random(1000000, 9999999))] = connection
		return connection
	end
	lib.disconnect = function(name)
		for title, connection in pairs(connections) do
			if title:find(name) == 1 then
				connection:Disconnect()
			end
		end
	end
	
	--// Functions
	local flyPart
	
	local function flyEnd()
		lib.disconnect("freecam")
		camera.CameraSubject = character
		pcall(function()
			character.PrimaryPart.Anchored = false
		end)
	end
	
	module.flyStart = function(enabled)
		if not enabled then flyEnd() return end
		local dir = {w = false, a = false, s = false, d = false}
		local cf = Instance.new("CFrameValue")
		local camPart = Instance.new("Part")
		camPart.Transparency = 1
		camPart.Anchored = true
		camPart.CFrame = camera.CFrame
		pcall(function()
			character.PrimaryPart.Anchored = true
		end)
		
		lib.connect("freecam", RunService.RenderStepped:Connect(function()
			local primaryPart = camPart
			camera.CameraSubject = primaryPart
			
			local speed = module.Options.Speed
			
			local x, y, z = 0, 0, 0
			if dir.w then z = -1 * speed end
			if dir.a then x = -1 * speed end
			if dir.s then z = 1 * speed end
			if dir.d then x = 1 * speed end
			if dir.q then y = 1 * speed end
			if dir.e then y = -1 * speed end
			
			primaryPart.CFrame = CFrame.new(
				primaryPart.CFrame.p,
				(camera.CFrame * CFrame.new(0, 0, -100)).p
			)
			
			local moveDir = CFrame.new(x,y,z)
			cf.Value = cf.Value:lerp(moveDir, module.Options.Smoothness)
			primaryPart.CFrame = primaryPart.CFrame:lerp(primaryPart.CFrame * cf.Value, module.Options.Smoothness)
		end))
		lib.connect("freecam", UserInputService.InputBegan:Connect(function(input, event)
			if event then return end
			local code, codes = input.KeyCode, Enum.KeyCode
			if code == codes.W then
				dir.w = true
			elseif code == codes.A then
				dir.a = true
			elseif code == codes.S then
				dir.s = true
			elseif code == codes.D then
				dir.d = true
			elseif code == codes.Q then
				dir.q = true
			elseif code == codes.E then
				dir.e = true
			elseif code == codes.Space then
				dir.q = true
			end
		end))
		lib.connect("freecam", UserInputService.InputEnded:Connect(function(input, event)
			if event then return end
			local code, codes = input.KeyCode, Enum.KeyCode
			if code == codes.W then
				dir.w = false
			elseif code == codes.A then
				dir.a = false
			elseif code == codes.S then
				dir.s = false
			elseif code == codes.D then
				dir.d = false
			elseif code == codes.Q then
				dir.q = false
			elseif code == codes.E then
				dir.e = false
			elseif code == codes.Space then
				dir.q = false
			end
		end))
	end
	
	--// Events
	Player.CharacterAdded:Connect(function(char)
		character = char
	end)
	
	return module
end)()

local _Freecam = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	    local character = Player.Character
	local camera = workspace.CurrentCamera
	
	local module = {}
	module.Options = {
		Speed = 5,
		Smoothness = 0.2,
	}
	
	local lib, connections = {}, {}
	lib.connect = function(name, connection)
		connections[name .. tostring(math.random(1000000, 9999999))] = connection
		return connection
	end
	lib.disconnect = function(name)
		for title, connection in pairs(connections) do
			if title:find(name) == 1 then
				connection:Disconnect()
			end
		end
	end
	
	--// Functions
	local flyPart
	
	local function flyEnd()
		lib.disconnect("freecam")
		camera.CameraSubject = character
		pcall(function()
			character.PrimaryPart.Anchored = false
		end)
	end
	
	module.flyStart = function(enabled)
		if not enabled then flyEnd() return end
		local dir = {w = false, a = false, s = false, d = false}
		local cf = Instance.new("CFrameValue")
		local camPart = Instance.new("Part")
		camPart.Transparency = 1
		camPart.Anchored = true
		camPart.CFrame = camera.CFrame
		pcall(function()
			character.PrimaryPart.Anchored = true
		end)
		
		lib.connect("freecam", RunService.RenderStepped:Connect(function()
			local primaryPart = camPart
			camera.CameraSubject = primaryPart
			
			local speed = module.Options.Speed
			
			local x, y, z = 0, 0, 0
			if dir.w then z = -1 * speed end
			if dir.a then x = -1 * speed end
			if dir.s then z = 1 * speed end
			if dir.d then x = 1 * speed end
			if dir.q then y = 1 * speed end
			if dir.e then y = -1 * speed end
			
			primaryPart.CFrame = CFrame.new(
				primaryPart.CFrame.p,
				(camera.CFrame * CFrame.new(0, 0, -100)).p
			)
			
			local moveDir = CFrame.new(x,y,z)
			cf.Value = cf.Value:lerp(moveDir, module.Options.Smoothness)
			primaryPart.CFrame = primaryPart.CFrame:lerp(primaryPart.CFrame * cf.Value, module.Options.Smoothness)
		end))
		lib.connect("freecam", UserInputService.InputBegan:Connect(function(input, event)
			if event then return end
			local code, codes = input.KeyCode, Enum.KeyCode
			if code == codes.W then
				dir.w = true
			elseif code == codes.A then
				dir.a = true
			elseif code == codes.S then
				dir.s = true
			elseif code == codes.D then
				dir.d = true
			elseif code == codes.Q then
				dir.q = true
			elseif code == codes.E then
				dir.e = true
			elseif code == codes.Space then
				dir.q = true
			end
		end))
		lib.connect("freecam", UserInputService.InputEnded:Connect(function(input, event)
			if event then return end
			local code, codes = input.KeyCode, Enum.KeyCode
			if code == codes.W then
				dir.w = false
			elseif code == codes.A then
				dir.a = false
			elseif code == codes.S then
				dir.s = false
			elseif code == codes.D then
				dir.d = false
			elseif code == codes.Q then
				dir.q = false
			elseif code == codes.E then
				dir.e = false
			elseif code == codes.Space then
				dir.q = false
			end
		end))
	end
	
	--// Events
	Player.CharacterAdded:Connect(function(char)
		character = char
	end)
	
	return module
end)()
local _Rubberbanding = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	    local Character = Player.Character
	
	local module = {}
	module.Options = {
		Enabled = false,
		Threshold = 150,
		UpdateSpeed = 100,
	}
	
	local connections = {}
	
	--// Functions
	local function getPart(Model)
		return Model.PrimaryPart or Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChildWhichIsA("Part")
	end
	
	local function connectPart(Part)
		local lastPosition = CFrame.new()
		local lastVelocity = Vector3.new()
		local lastRender = tick()
		
		connections[#connections+1] = RunService.RenderStepped:Connect(function()
			if not module.Options.Enabled then return end
			
			if Part and (tick() - lastRender >= module.Options.UpdateSpeed / 1000) then
				if (lastVelocity - Part.Velocity).Magnitude > module.Options.Threshold and Part.Velocity.Magnitude > lastVelocity.Magnitude then
					Part.Velocity = lastVelocity
					Part.CFrame = lastPosition
				end
				
				lastPosition = Part.CFrame
				lastVelocity = Part.Velocity
				lastRender = tick()
			end
		end)
	end
	
	local function onCharacter(char)
		Character = char
		for i, v in pairs(connections) do
			v:Disconnect()
			connections[i] = nil
		end
		for _, part in pairs(char:GetChildren()) do
			if part.Name == "HumanoidRootPart" then
				connectPart(part)
			end
		end
		connections[#connections+1] = Character.ChildAdded:Connect(function(child)
			if child.Name == "HumanoidRootPart" then
				connectPart(child)
			end
		end)
	end
	
	
	module.Toggle = function(enabled)
		module.Options.Enabled = enabled
		for i, v in pairs(connections) do
			v:Disconnect()
			connections[i] = nil
		end
		if enabled and Character then
			onCharacter(Character)
		end
	end
	
	--// Events
	Player.CharacterAdded:Connect(function(char)
		onCharacter(char)
	end)
	
	if Character then
		onCharacter(Character)
	end
	
	return module
	
end)()
local _AntiTP = (function()
	--// Variables
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
	  local Player = Players.LocalPlayer
	    local Character = Player.Character
	
	local module = {}
	module.Options = {
		Enabled = false,
		Threshold = 150,
		UpdateSpeed = 100,
	}
	
	local connections = {}
	
	--// Functions
	local function getPart(Model)
		return Model.PrimaryPart or Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChildWhichIsA("Part")
	end
	
	local function connectPart(Part)
		local lastPosition = Part.CFrame
		local lastRender = tick()
		
		connections[#connections+1] = RunService.RenderStepped:Connect(function()
			if not module.Options.Enabled then return end
			
			if Part and (tick() - lastRender >= module.Options.UpdateSpeed / 1000) then
				if (lastPosition.p - Part.Position).Magnitude > module.Options.Threshold then
					Part.CFrame = lastPosition
					Part.Velocity = Vector3.new(0, 0, 0)
				end
				
				lastPosition = Part.CFrame
				lastRender = tick()
			end
		end)
	end
	
	local function onCharacter(char)
		Character = char
		for i, v in pairs(connections) do
			v:Disconnect()
			connections[i] = nil
		end
		for _, part in pairs(char:GetChildren()) do
			if part.Name == "HumanoidRootPart" then
				connectPart(part)
			end
		end
		connections[#connections+1] = Character.ChildAdded:Connect(function(child)
			if child.Name == "HumanoidRootPart" then
				connectPart(child)
			end
		end)
	end
	
	module.Toggle = function(enabled)
		module.Options.Enabled = enabled
		for i, v in pairs(connections) do
			v:Disconnect()
			connections[i] = nil
		end
		if enabled and Character then
			onCharacter(Character)
		end
	end
	
	--// Events
	Player.CharacterAdded:Connect(function(char)
		onCharacter(char)
	end)
	
	if Character then
		onCharacter(Character)
	end
	
	return module
	
end)()


-- UI Library
-- local notifications = loadstring(game:HttpGet(("https://pastebin.com/raw/Eit6Pijx"),true))()
local uilibrary = loadstring(game:HttpGet("https://pastebin.com/raw/uUZ2vT7M"))()
local windowz = uilibrary:CreateWindow("Kaos Hub", "Fruit Battlegrounds [version 1.4]", true)

local Main = windowz:CreatePage("Farm")
local Skills = windowz:CreatePage("Skills")
local Misc = windowz:CreatePage("Misc")
local Visual = windowz:CreatePage("Visual")
local Spin = windowz:CreatePage("Spin")
local Bounty = windowz:CreatePage("Bounty")
local Teleport = windowz:CreatePage("Teleport")
local Settings = windowz:CreatePage("Settings")
local Credits = windowz:CreatePage("Credits")

local MainSection = Main:CreateSection("Attack")
local SkillSection = Skills:CreateSection("Skills")
local MiscSection = Misc:CreateSection("Misc")
local AntiSection = Misc:CreateSection("Other")
local StatsSection = Misc:CreateSection("Player Stats")
local BountySection = Bounty:CreateSection("Bounty Farm") 
local BountySection2 = Bounty:CreateSection("Spectate") 
local TeleportSection = Teleport:CreateSection("NPCs") 
local TeleportSection2 = Teleport:CreateSection("Areas") 
local SpinSection = Spin:CreateSection("Spin") 
local SettingsSection = Settings:CreateSection("Server") 
local XPSection = Main:CreateSection("XP Farm") 
local ESPSection = Misc:CreateSection("ESP Config") 
local PlrSection = Misc:CreateSection("Player") 
local CreditsSection = Credits:CreateSection("Thanks to :o")
local GraphicsSection = Visual:CreateSection("Graphics")

notifications:notify{
	Title = "Announcement",
	Description = "You have been Whitelisted to Kaos Hub, Copy Discord?",
	Accept = {
	Text = "Yes",
		Callback = function()
			setclipboard("https://discord.gg/rSFUUphKpm")
		end,
	},
	Dismiss = {
		Text = "No",
		Callback = function()
			print("Declined")
		end, 
	}
}



local Fruitselected
local SkillSelected
local SkillDelay = 1 -- Adjust the delay time as needed

getgenv().autoskill = false 
getgenv().autoattack = false
getgenv().safePlaceEnabled = false

local function autoskill(skills)
    while getgenv().autoskill do 
        for _, skill in ipairs(skills) do
            local v1 = Fruitselected
            local v2 = skill

            local event = game:GetService("ReplicatedStorage").ReplicatorNoYield

            event:FireServer(v1, v2)
            wait(SkillDelay)
        end
    end 
end 

local function autoattack()
    while getgenv().autoattack == true do 
        local v1 = "Core"
        local v2 = "M1"
        local v3 = {}

        local event = game:GetService("ReplicatedStorage").Replicator

        event:InvokeServer(v1, v2, v3)
        wait() -- You can adjust the delay here if needed
    end 
end

SkillSection:CreateDropdown("Fruit", {
    List = {"Quake","Gravity","Phoenix","Paw","Magma","Flame","Light","Ice","Bomb","Sand","Darkness","Rubber","Smoke","Barrier","Chop","Nika","Dragon","Timeskip Rubbery","Ope","Rumble","Gas","Venom","Falcon", "Leopard"},
    Default = "Nothing"}, function(value)

    Fruitselected = value
end)

SkillSection:CreateTextbox("Skills (comma-separated)", false, function (vv)
    local skills = {}
    for skill in vv:gmatch("%S+") do
        table.insert(skills, skill)
    end
    autoskill(skills)
end)

local autoSkillToggle = SkillSection:CreateToggle("Auto Skill", {Toggled=configs.AutoSkill , Description = "Auto uses Fruit Skills!"}, function(bool)
	configs.AutoSkill = bool
    getgenv().autoskill = bool
end)

SkillSection:CreateButton("Stop Auto Skill", function ()
    getgenv().autoskill = false 
end)

SkillSection:CreateSlider("Skill Delay", {Min = 1, Max = 15, DefaultValue = 1}, function(Value)
    SkillDelay = Value
end)

MainSection:CreateToggle("Auto Attack", {Toggled=configs.AutoAttack, Description = "Auto M1s"}, function(bool)
    getgenv().autoattack = bool
    while bool do 
        wait()
        autoattack() 
    end
	configs.AutoAttack = bool
end)


local playerlist = {}

for i, v in pairs(game.Players:GetPlayers()) do
    if v ~= game.Players.LocalPlayer then
        table.insert(playerlist, v.Name)
    end
end

game.Players.PlayerAdded:Connect(function(player)
    local name = player.Name
    table.insert(playerlist, name)
end)

game.Players.PlayerRemoving:Connect(function(player)
    local name = player.Name
    for i, v in pairs(playerlist) do
        if v == name then
            table.remove(playerlist, i)
        end
    end
    drop:Refresh(playerlist)
end)

local selectedplr
local teleportDistance = 10 -- Set your default teleportation distance here
getgenv().loopTp = false

local function loopTp()
    while getgenv().loopTp == true do
        wait()
        local targetCharacter = game.Players[selectedplr].Character
        local localCharacter = game.Players.LocalPlayer.Character

        if targetCharacter and localCharacter then
            local targetPosition = targetCharacter.HumanoidRootPart.Position
            local localPosition = localCharacter.HumanoidRootPart.Position
            local direction = (targetPosition - localPosition).unit
            local behindPosition = targetPosition - direction * teleportDistance

            -- Teleport to a position that is 'teleportDistance' studs behind the target
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(behindPosition)
        end
    end
end

BountySection:CreateTextbox("Username", false, function(vv)
    selectedplr = vv
end)

BountySection:CreateDropdown("Select Player", {
    List = playerlist,
    Default = "None"
}, function(value)
    selectedplr = value
end)

BountySection:CreateSlider("Teleport Distance", {
    Min = 1,
    Max = 50, -- Set your desired maximum teleport distance
    DefaultValue = 7
}, function(value)
    teleportDistance = value
end)

BountySection:CreateToggle("Teleport Behind Selected Player", {
    Toggled = false,
    Description = "Teleports you behind the Player!"
}, function(bool)
    getgenv().loopTp = bool
    if bool then
        loopTp()
    end
end)




-- no clip for autofarm
game:GetService("RunService").RenderStepped:Connect(function() 
	if loopTp == true then
		game.Players.LocalPlayer.Character.Humanoid:ChangeState(11)
	end
 end)

 getgenv().pf = false 
 

 local function toTarget(pos, targetPos, targetCFrame)
    local tween_s = game:GetService("TweenService")
    local info = TweenInfo.new((targetPos - pos).Magnitude / 300, Enum.EasingStyle.Quad)
    
    local tween = tween_s:Create(game.Players.LocalPlayer.Character.HumanoidRootPart, info, {CFrame = targetCFrame})
    
    tween:Play()
end

local function pf()
    while getgenv().pf == true do
        for _, c in ipairs(game.Players:GetPlayers()) do
            if c.Name ~= game.Players.LocalPlayer.Name and c.Character and c.Character:FindFirstChild("HumanoidRootPart") and c.Character:FindFirstChildWhichIsA("Humanoid").Health > 0 and game.Players.LocalPlayer.Character then
                toTarget(game.Players.LocalPlayer.Character.HumanoidRootPart.Position, c.Character.HumanoidRootPart.Position, c.Character.HumanoidRootPart.CFrame)
                
                local v1 = "Core"
                local v2 = "M1"
                local v3 = {}
                
                local event = game:GetService("ReplicatedStorage").Replicator
                event:FireServer(v1, v2, v3) -- Assuming this is how your event works
            end
        end
        task.wait() -- Ensure you have "task" properly defined
    end
end

 BountySection:CreateToggle("Farm All Players", {Toggled=configs.FarmAllPlayers, Description = "Tweens you to All the Players in current Server"}, function(bool)
	getgenv().pf = bool
	configs.FarmAllPlayers = bool
	while bool do
	   task.wait()
	   pf()
	end 
end)

local tweenspeed
local tweenspeed2


TeleportSection:CreateButton("Teleport Titles NPC", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").NPCs["Titles NPC"].RootPart.Position)})
tween:Play()
 end)

 TeleportSection:CreateButton("Teleport Mystery Guy NPC", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").NPCs["Mystery Guy"].HumanoidRootPart.Position)})
tween:Play()
 end)

 TeleportSection:CreateButton("Teleport Sorus Book", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").NPCs["Soru Book"].HumanoidRootPart.Position)})
tween:Play()
 end)

 TeleportSection:CreateButton("Teleport Kuma", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").NPCs.Kuma.HumanoidRootPart.Position)})
tween:Play()
 end)

 TeleportSection:CreateButton("Teleport Tournament Register", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").NPCs["Tournament Register"].HumanoidRootPart.Position)})
tween:Play()
 end)

 TeleportSection:CreateSlider("Tween Speed", {Min = 1, Max = 10, DefaultValue = 1}, function(Value)
	tweenspeed = Value
 end)






 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 TeleportSection2:CreateButton("Teleport Colloseum", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed2, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").Areas.Colloseum.Position)})
tween:Play()
 end)

 TeleportSection2:CreateButton("Teleport Forest", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed2, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").Areas.Forest.Position)})
tween:Play()
 end)

 TeleportSection2:CreateButton("Teleport Dressrosa", function ()
	tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(tweenspeed2, Enum.EasingStyle.Linear)

tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(game:GetService("Workspace").Areas.Dressrosa.Position)})
tween:Play()
 end)

 TeleportSection2:CreateSlider("Tween Speed", {Min = 1, Max = 10, DefaultValue = 1}, function(Value)
	tweenspeed2 = Value
 end)



 AntiSection:CreateToggle("Disable Stun", {Toggled=configs.NoStun , Description = false}, function(v)
	configs.NoStun = v
	if v == true then
	game:GetService("RunService").RenderStepped:Connect(function()
		for i, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
			if v:IsA("BasePart") then
				if v.Anchored == true then
					v.Anchored = false
				end
			end
		end
	end)

else 
	for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v.Name == "Stunned" then
			   v:Destroy()
		end
 end
end
 end)

 AntiSection:CreateToggle("Disable Burn", {Toggled=configs.NoBurn , Description = false}, function(v)
	configs.NoBurn = v
	if v == true then
	game:GetService("ReplicatedStorage").Assets.Effects.Fire:Destroy()
	game:GetService("ReplicatedStorage").Loader.ClientEffects.Falcon.FalconPunch.Impact.Attachment:Destroy()
	game:GetService("ReplicatedStorage").Loader.ClientEffects.Falcon.FalconPunch.Falcon.Part:Destroy()
	game:GetService("ReplicatedStorage").Loader.ClientEffects.Gas.CombustiveGas.Ball.Attachment:Destroy()
	game:GetService("ReplicatedStorage").Loader.ClientEffects.Gas.CombustiveGas.Ball.Attachment:Destroy()
	else 
		for _, v in pairs(game.Workspace.Characters:GetChildren()) do
			if v.Name == "EmptyPart" then
				v:Destroy()
			end
		end
	end
 end)

 AntiSection:CreateToggle("No Cooldown", {Toggled=configs.NoCd , Description = false}, function(v)
	configs.NoCd = v
	if v == true then
        for _, v in pairs(game.Players.LocalPlayer.Cooldowns:GetChildren()) do
            if v:IsA("NumberValue") then
                v:Destroy()
            end
        end
	end
 end)

 AntiSection:CreateButton("Redeem All Codes", function ()
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "LETSGOO400"
        }
    }
    wait(1)
    game:GetService("ReplicatedStorage"):WaitForChild("Replicator"):InvokeServer(unpack(args))
    
    local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "JOYBOYY"
        }
    }
	wait(1)
    game:GetService("ReplicatedStorage"):WaitForChild("Replicator"):InvokeServer(unpack(args))
    
    local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "HEARDADRUMS"
        }
    }
	wait(1)
    game:GetService("ReplicatedStorage"):WaitForChild("Replicator"):InvokeServer(unpack(args))
    
    local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "SUPEREVENT!"
        }
    }
	wait(1)
    game:GetService("ReplicatedStorage"):WaitForChild("Replicator"):InvokeServer(unpack(args))
    
    local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "SHEEESH390!"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "CHEF470K!"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "460KRAZY!!"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "SIZZLIN450!!"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "SIZZLIN450!!"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "420BLAZE"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "CRAZYYY410!"
        }
    }
	wait(1)
	local args = {
        [1] = "Codes",
        [2] = "Redeem",
        [3] = {
            ["Code"] = "CRAZYYY410!"
        }
    }
	wait(1)
    game:GetService("ReplicatedStorage"):WaitForChild("Replicator"):InvokeServer(unpack(args))
 end)


 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 MiscSection:CreateToggle("Fly", {Toggled=false , Description = false}, function(enabled)
	_Flight.flyStart(enabled)
 end)

 MiscSection:CreateSlider("Flight Speed", {Min = 1, Max = 20, DefaultValue = 2}, function(value)
	_Flight.Options.Speed = value
 end)

 MiscSection:CreateToggle("Free Cam", {Toggled=false , Description = false}, function(enabled)
	_Freecam.flyStart(enabled)
end)

 MiscSection:CreateSlider("Cam Speed", {Min = 1, Max = 10, DefaultValue = 5}, function(value)
	_Freecam.Options.Speed = value
 end)
-- Create a table to store the player's choices
-- Create a table to store the player's choices
local playerChoices = {
    selectedFruit = "None", -- Default value
    selectedSlot = 1, -- Default slot is 1
    autoSpin = false,
    stopOnMythicals = false
}

-- Function to spin for the selected fruit
local function spinForFruit(fruit)
    local string_1 = "FruitsHandler"
    local string_2 = "Spin"
    local table_1 = {
        ["Fruit"] = fruit,
        ["Slot"] = playerChoices.selectedSlot
    }
    game:GetService("ReplicatedStorage").Replicator:InvokeServer(string_1, string_2, table_1)
end

-- Function to check if the current fruit is mythical or legendary
local function isMythicalOrLegendary(fruit)
    return fruit == "Nika" or fruit == "Dragon" or fruit == "Lightning" or fruit == "Leopard" or fruit == "Ope" or fruit == "Venom" or fruit == "Quake" or fruit == "Gravity" or fruit == "Magnet" or fruit == "Phoenix" or fruit == "TSRubber"
end

-- Main loop to handle spinning
spawn(function()
    while true do
        wait(2)
        if playerChoices.autoSpin then
            spinForFruit(playerChoices.selectedFruit)
        else
            break -- Exit the loop if autoSpin is turned off
        end
    end
end)

SpinSection:CreateDropdown("Select Fruit to Spin for", {
    List = {"Quake","Gravity","Phoenix","Paw","Magma","Flame","Light","Ice","Bomb","Sand","Dark","Rubber","Smoke","Barrier","Chop","Sun God","Dragon","Timeskip Rubbery","Ope","Gas","Lightning", "Leopard"},
    Default = "None"
}, function(value)
    playerChoices.selectedFruit = value
end)

SpinSection:CreateDropdown("Select Slot to Spin On", {
    List = {"1", "2", "3", "4"},
    Default = "1"
}, function(value)
    playerChoices.selectedSlot = tonumber(value) -- Convert the value to a number
end)

SpinSection:CreateToggle("Auto Spin", {Toggled = false, Description = false}, function(value)
    playerChoices.autoSpin = value
    if value then
        spinForFruit(playerChoices.selectedFruit)
    end
end)

SpinSection:CreateToggle("Auto Spin for Mythicals and Legendary only", {Toggled = false, Description = false}, function(value)
    playerChoices.stopOnMythicals = value
end)




	SettingsSection:CreateButton("Rejoin", function ()
		game:GetService("TeleportService"):Teleport(game.PlaceId, game:GetService("Players").LocalPlayer)
	 end)

	 SettingsSection:CreateButton("Server Hop", function ()
		local Player = game.Players.LocalPlayer    
		local Http = game:GetService("HttpService")
		local TPS = game:GetService("TeleportService")
		local Api = "https://games.roblox.com/v1/games/"
		
		local _place,_id = game.PlaceId, game.JobId
		local _servers = Api.._place.."/servers/Public?sortOrder=Desc&limit=100"
		function ListServers(cursor)
		   local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
		   return Http:JSONDecode(Raw)
		end
		
		local Next; repeat
		   local Servers = ListServers(Next)
		   for i,v in next, Servers.data do
			   if v.playing < v.maxPlayers and v.id ~= _id then
				   local s,r = pcall(TPS.TeleportToPlaceInstance,TPS,_place,v.id,Player)
				   if s then break end
			   end
		   end
		   
		   Next = Servers.nextPageCursor
		until not Next
		 end)

		 SettingsSection:CreateButton("Server Hop to Low Server", function ()
			local Http = game:GetService("HttpService")
			local TPS = game:GetService("TeleportService")
			local Api = "https://games.roblox.com/v1/games/"
			
			local _place = game.PlaceId
			local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"
			function ListServers(cursor)
			   local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
			   return Http:JSONDecode(Raw)
			end
			
			local Server, Next; repeat
			   local Servers = ListServers(Next)
			   Server = Servers.data[1]
			   Next = Servers.nextPageCursor
			until Server
			
			TPS:TeleportToPlaceInstance(_place,Server.id,game.Players.LocalPlayer)
			 end)

			 LocalLevel = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.Level.Text
			 LocalEXP = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.EXP.Text
			 LocalStamina = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.Bars.ProgressStamina.Text
			 local playerName = game.Players.LocalPlayer.Name


			 StatsSection:CreateButton("Current Level " .. LocalLevel .. "" , function ()
				notifications:notify{
					Title = "Kaos Hub",
					Description = "Updated Level of " .. playerName .. ", Level " .. LocalLevel,
					Accept = {
						Text = "Okay"
					},
					Length = 3
				}
			 end)

			 StatsSection:CreateButton("Current EXP " .. LocalEXP .. "" , function ()
				notifications:notify{
					Title = "Kaos Hub",
					Description = "Updated EXP of " .. playerName .. ", Level " .. LocalEXP,
					Accept = {
						Text = "Okay"
					},
					Length = 3
				}
			 end)

			 StatsSection:CreateButton("Current Stamina " .. LocalStamina .. "" , function ()
				notifications:notify{
					Title = "Kaos Hub",
					Description = "Updated Stamina of " .. playerName .. ", Level " .. LocalStamina,
					Accept = {
						Text = "Okay"
					},
					Length = 3
				}
			 end)

			 GraphicsSection:CreateToggle("Smooth-High Graphics [dont use with other skybox or time]", {Toggled=false , Description = false}, function(Value)
			if Value == true then 
sethiddenproperty(game:GetService("Workspace").Terrain, "Decoration", true)
sethiddenproperty(game:GetService("Lighting"), "Technology", "Future")

local ter = workspace.Terrain
local color = Instance.new("ColorCorrectionEffect")
local bloom = Instance.new("BloomEffect")
local sun = Instance.new("SunRaysEffect")
local blur = Instance.new("BlurEffect")

color.Parent = light
bloom.Parent = light
sun.Parent = light
blur.Parent = light

-- enable or disable shit

local config = {

	Terrain = true;
	ColorCorrection = true;
	Sun = true;
	Lighting = true;
	BloomEffect = true;
	
}

-- settings {

color.Enabled = false
color.Contrast = 0.15
color.Brightness = 0.1
color.Saturation = 0.25
color.TintColor = Color3.fromRGB(255, 222, 211)

bloom.Enabled = false
bloom.Intensity = 0.1

sun.Enabled = false
sun.Intensity = 0.2
sun.Spread = 1

bloom.Enabled = false
bloom.Intensity = 0.05
bloom.Size = 32
bloom.Threshold = 1

blur.Enabled = false
blur.Size = 6

-- settings }


if config.ColorCorrection then
	color.Enabled = true
end


if config.Sun then
	sun.Enabled = true
end


if config.Terrain then
	-- settings {
	ter.WaterColor = Color3.fromRGB(10, 10, 24)
	ter.WaterWaveSize = 0.1
	ter.WaterWaveSpeed = 22
	ter.WaterTransparency = 0.9
	ter.WaterReflectance = 0.05
	-- settings }
end


if config.Lighting then
	-- settings {
	light.Ambient = Color3.fromRGB(0, 0, 0)
	light.Brightness = 4
	light.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
	light.ColorShift_Top = Color3.fromRGB(0, 0, 0)
	light.ExposureCompensation = 0
	light.FogColor = Color3.fromRGB(132, 132, 132)
	light.GlobalShadows = true
	light.OutdoorAmbient = Color3.fromRGB(112, 117, 128)
	light.Outlines = false
	-- settings }
end
end
			 end)


			 GraphicsSection:CreateDropdown("Skyboxes", {
				List = {"Anime", "Skeleton Dancing"},
				Default = "None"}, function(State)
					if State == "Anime" then 
						s = Instance.new("Sky")
						s.Parent = game.Lighting
						s.Name = "awesome skybox"
						while true do
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21076888"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21076888"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21076888"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21076888"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21076888"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21076888"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21076945"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077007"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077125"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077227"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077345"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077345"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077345"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077345"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077345"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077345"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077227"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077227"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077125"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077125"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21077007"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21077007"
						wait(0.1)
						s.SkyboxBk = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxDn = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxFt = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxLf = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxRt = "http://www.roblox.com/asset/?id=21076945"
						s.SkyboxUp = "http://www.roblox.com/asset/?id=21076945"
						end
					elseif State == "Skeleton Dancing" then 
						imageOne = "http://www.roblox.com/asset/?id=169585459"
imageTwo = "http://www.roblox.com/asset/?id=169585475"
imageThree = "http://www.roblox.com/asset/?id=169585485"
imageFour = "http://www.roblox.com/asset/?id=169585502"
imageFive = "http://www.roblox.com/asset/?id=169585515"
imageSix = "http://www.roblox.com/asset/?id=169585502"
imageSeven = "http://www.roblox.com/asset/?id=169585485"
imageEight = "http://www.roblox.com/asset/?id=169585475"

Spooky = Instance.new("Sound", workspace)
Spooky.Name = "Spooky"
Spooky.SoundId = "rbxassetid://174270407"
Spooky.Volume = 15
Spooky.Looped = true
Spooky:Play()

Sky = Instance.new("Sky", game.Lighting)
Sky.SkyboxBk = imageOne
Sky.SkyboxDn = imageOne
Sky.SkyboxFt = imageOne
Sky.SkyboxLf = imageOne
Sky.SkyboxRt = imageOne
Sky.SkyboxUp = imageOne


while true do
    Sky.SkyboxBk = imageOne
    Sky.SkyboxDn = imageOne
    Sky.SkyboxFt = imageOne
    Sky.SkyboxLf = imageOne
    Sky.SkyboxRt = imageOne
    Sky.SkyboxUp = imageOne
    wait(0.15)
    Sky.SkyboxBk = imageTwo
    Sky.SkyboxDn = imageTwo
    Sky.SkyboxFt = imageTwo
    Sky.SkyboxLf = imageTwo
    Sky.SkyboxRt = imageTwo
    Sky.SkyboxUp = imageTwo
    wait(0.15)
    Sky.SkyboxBk = imageThree
    Sky.SkyboxDn = imageThree
    Sky.SkyboxFt = imageThree
    Sky.SkyboxLf = imageThree
    Sky.SkyboxRt = imageThree
    Sky.SkyboxUp = imageThree
    wait(0.15)
    Sky.SkyboxBk = imageFour
    Sky.SkyboxDn = imageFour
    Sky.SkyboxFt = imageFour
    Sky.SkyboxLf = imageFour
    Sky.SkyboxRt = imageFour
    Sky.SkyboxUp = imageFour
    wait(0.15)
    Sky.SkyboxBk = imageFive
    Sky.SkyboxDn = imageFive
    Sky.SkyboxFt = imageFive
    Sky.SkyboxLf = imageFive
    Sky.SkyboxRt = imageFive
    Sky.SkyboxUp = imageFive
    wait(0.15)
    Sky.SkyboxBk = imageSix
    Sky.SkyboxDn = imageSix
    Sky.SkyboxFt = imageSix
    Sky.SkyboxLf = imageSix
    Sky.SkyboxRt = imageSix
    Sky.SkyboxUp = imageSix
    wait(0.15)
    Sky.SkyboxBk = imageSeven
    Sky.SkyboxDn = imageSeven
    Sky.SkyboxFt = imageSeven
    Sky.SkyboxLf = imageSeven
    Sky.SkyboxRt = imageSeven
    Sky.SkyboxUp = imageSeven
    wait(0.15)
    Sky.SkyboxBk = imageEight
    Sky.SkyboxDn = imageEight
    Sky.SkyboxFt = imageEight
    Sky.SkyboxLf = imageEight
    Sky.SkyboxRt = imageEight
    Sky.SkyboxUp = imageEight
    wait(0.15)
    
end

end
			 end)

			 AntiSection:CreateButton("Unlock FPS", function ()
				setfpscap(99999)
			 end)

			 GraphicsSection:CreateDropdown("Time", {
				List = {"Day", "Dark"},
				Default = "None"}, function(State)
					if State == "Dark" then 
						-- Get the Lighting object
					local lighting = game:GetService("Lighting")
					
					-- Set the time of day to nighttime
					lighting.TimeOfDay = "21:00:00" -- You can adjust the time as needed for nighttime
					
					-- Adjust other lighting properties for a nighttime look (optional)
					lighting.Brightness = 0.2 -- Lower value for a darker look
					lighting.FogEnd = 200 -- Adjust to your preference
					lighting.OutdoorAmbient = Color3.new(0, 0, 0) -- Set to a dark color
					elseif State == "Day" then 
						-- Get the Lighting object
					local lighting = game:GetService("Lighting")
					
					-- Set the time of day to daytime
					lighting.TimeOfDay = "14:00:00" -- You can adjust the time as needed
					
					-- Adjust other lighting properties for a daytime look (optional)
					lighting.Brightness = 2 -- Adjust to your preference
					lighting.FogEnd = 100 -- Adjust to your preference
					end
			 end)

------------------------------------------------------------------------------------------------------------------------------------


local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

getgenv().xpfarm = false

function split(source, delimiters)
    local elements = {}
    local pattern = '([^' .. delimiters .. ']+)'
    string.gsub(source, pattern, function(value) elements[#elements + 1] = value; end)
    return elements
end

local staminaThreshold = 0.25

local lastXPWebhookTime = 0  -- Initialize a variable to store the last time the XPWebhook was sent
 -- Define the variable to store the webhook URL


function xpfarm()
    local enabled = false -- Track whether the XP farm is enabled
    while getgenv().xpfarm == true do
        pcall(function()
            local plr = game.Players.LocalPlayer.Character
            if plr == nil then
                task.wait(5)
                local Event = game:GetService("ReplicatedStorage").Replicator
                local args = {
                    [1] = "Core",
                    [2] = "LoadCharacter",
                    [3] = {}
                }
                Event:InvokeServer(unpack(args))

                local Event = game:GetService("ReplicatedStorage").ReplicatorNoYield
                local args = {
                    [1] = "Main",
                    [2] = "Core",
                    [3] = {}
                }
                Event:FireServer(unpack(args))

                local Event = game:GetService("ReplicatedStorage").ReplicatorNoYield
                local args = {
                    [1] = "Main",
                    [2] = "LoadCharacter"
                }
                Event:FireServer(unpack(args))
            else
                local path = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.Bars.ProgressStamina.Text
                local exit = (split(path, "/"))
                local currentStamina = tonumber(exit[1]) / tonumber(exit[2])

                if currentStamina <= staminaThreshold and enabled then
                    -- Disable XP farm when stamina is low
                    getgenv().xpfarm = true
                    enabled = false
                elseif currentStamina > staminaThreshold and not enabled then
                    -- Enable XP farm when stamina is above the threshold
                    getgenv().xpfarm = true
                    enabled = true
                end

                if enabled then
                    _G.xpfarm = true
                    for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
                        local x = string.split(v.Name, " ")
                        if x[2] ~= nil then
                            v.Name = x[1] .. x[2]
                        end
                    end
                    wait(0.1)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-1276, 696, -190)
                    for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
                        local ohString1 = game.Players.LocalPlayer["MAIN_DATA"].Slots[game.Players.LocalPlayer["MAIN_DATA"].Slot.Value].Value
                        local ohString2 = v.Name
                        local ohTable3 = {}
                        game:GetService("ReplicatedStorage").Replicator:InvokeServer(ohString1, ohString2, ohTable3)
                    end   
                end
            end
        end)
        task.wait() -- Add a small delay to avoid continuously executing this loop
    end
end

spawn(function()
    while task.wait(.5) do
        pcall(function()
            local vu = game:GetService("VirtualUser")
            game:GetService("Players").LocalPlayer.Idled:connect(function()
                vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                wait(1)
                vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.Cframe)
            end)
        end)
    end
end)

local XPFarmToggle
local urlTextBox

local function sendXPWebhook()
    while true do
        wait(300)  -- Wait for 300 seconds between sending webhooks
        
        if getgenv().xpfarm and urlTextBox then
            XPWebhook(urlTextBox)
        end
    end
end

local XPFarmToggle = XPSection:CreateToggle("XP Farm", { Toggled =configs.XpFarm, Description = false }, function(bool)
    getgenv().xpfarm = bool
    if bool then
        task.wait()
		xpfarm()
        spawn(sendXPWebhook)
    end
	configs.XpFarm = bool
end)


XPSection:CreateTextbox("Webhook", false, function (vv)
	configs.Webhook = vv
    urlTextBox = vv -- Store the entered URL in the variable
end)

XPSection:CreateButton("Test Webhook", function ()
	if urlTextBox then
        XPWebhook(urlTextBox) -- Pass the URL to the function
    else
        warn("Webhook URL is empty.")
    end
end)




function XPWebhook(url)
    if not url or url == "" then
        print("Webhook URL is empty or invalid.")local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local Players = game:GetService("Players")
		local Workspace = game:GetService("Workspace")
		
		if Workspace.CurrentCamera.CameraType == Enum.CameraType.Scriptable then
		   require(ReplicatedStorage.Loader).ServerEvent("Core", "LoadCharacter", {})
		   require(ReplicatedStorage.Loader).ServerEvent("Main", "LoadCharacter")
		   local Clone = Workspace.CurrentCamera:Clone()
		   Workspace.CurrentCamera:Destroy()
		   Clone.CameraType = Enum.CameraType.Custom
		   Clone.CameraSubject = Players.LocalPlayer.Character
		   Clone.Parent = Workspace
		   Players.LocalPlayer.PlayerGui.UI.MainMenu.Visible = false
		   Players.LocalPlayer.PlayerGui.UI.HUD.Visible = true
		end
        return
    end

    local LocalLevel = game.Players.LocalPlayer.PlayerGui.UI.HUD.Level.Text
    local LocalEXP = game.Players.LocalPlayer.PlayerGui.UI.HUD.EXP.Text
    local LocalStamina = game.Players.LocalPlayer.PlayerGui.UI.HUD.Bars.ProgressStamina.Text

    local data = {
        username = "Kaos Hub!", -- Main discord user
        avatar_url = "https://cdn.discordapp.com/attachments/1159138051042324650/1161023647465619456/68747470733a2f2f6d656469612e646973636f72646170702e6e65742f6174746163686d656e74732f3831333334313636323534353331333833322f3831333334333430343530373236373039322f706f6b656d6f6e5f706978656c2e676966.png?ex=6536ca88&is=65245588&hm=03584d80bc962d2a5b2f1af23ff1308722565481b107edc0c93549744270eeef&", -- Discord pfp
        embeds = {
            {
                title = "**Fruit Battlegrounds**",
                description = "**__Username__** : ||" .. game.Players.LocalPlayer.DisplayName .. "||\n__Local Level__ : " .. LocalLevel .. "\n__Local EXP__ : " .. LocalEXP .. "\n__Local Stamina__ : " .. LocalStamina .. "",
                type = "rich",
                color = 0xa020f0,
                footer = {
                    text = "Sent by Kaos Hub - Premium Scripts",
                    icon_url = "https://cdn.discordapp.com/attachments/1159138051042324650/1159546155655512085/kaoshub3-removebg-preview.png?ex=65316a82&is=651ef582&hm=484cb377e94ed9ed05b5ead141f7889892ffa67b60fc1693966396709e3826aa&",
                },
                author = {
                    name = "Kaos Hub",
                    icon_url = "https://cdn.discordapp.com/attachments/1159138051042324650/1159546155655512085/kaoshub3-removebg-preview.png?ex=65316a82&is=651ef582&hm=484cb377e94ed9ed05b5ead141f7889892ffa67b60fc1693966396709e3826aa&",
                    url = "https://google.com",
                },
            },
        },
    }

    local jsonData = game:GetService("HttpService"):JSONEncode(data)
    local headers = {
        ["content-type"] = "application/json",
    }

    local request = http_request or request or HttpPost or syn.request
    local requestData = {
        Url = url,
        Method = "POST",
        Headers = headers,
        Body = jsonData,
    }

    local success, response = pcall(request, requestData)

    if success then
        print("Webhook sent successfully.")
    else
        warn("Failed to send webhook:", response)
    end
end

local Esp = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/x114/RobloxScripts/main/OpenSourceEsp"))()
-- Boxes --





ESPSection:CreateToggle("Enable Box", {Toggled=configs.ESPBox , Description = false}, function(Value)
	configs.ESPBox = Value
	Esp.Box = Value
 end)
 
 ESPSection:CreateColorPicker("Box Color", Color3.fromRGB(255, 255, 255), function (v)
	Esp.BoxColor = v
 end)

 ESPSection:CreateToggle("Box Outline", {Toggled=configs.ESPBoxOutline , Description = false}, function(Value)
	configs.ESPBoxOutline = Value
	Esp.BoxOutline = Value
 end)


 ESPSection:CreateColorPicker("Box Color", Color3.fromRGB(255, 255, 255), function (v)
	Esp.BoxOutlineColor = v
 end)

 ESPSection:CreateToggle("Enable Health Bar", {Toggled=configs.ESPHealthBar , Description = false}, function(Value)
	configs.ESPHealthBar = Value
	HealthBar = Value
 end)

 ESPSection:CreateDropdown("Health Bar Position", {
	List = {"Left","Bottom","Right"},
	Default = "Left"}, function(State)
		if State == "Left" then 
			Esp.HealthBarSide = "Left"
		elseif State == "Bottom" then 
			Esp.HealthBarSide = "Bottom"
		elseif State == "Right" then 
			Esp.HealthBarSide = "Right"
		end
 end)

 ESPSection:CreateToggle("Enable Names", {Toggled=configs.ESPNames , Description = false}, function(Value)
	configs.ESPNames = Value
	Esp.Names = Value
 end)

 ESPSection:CreateColorPicker("Names Color", Color3.fromRGB(255, 255, 255), function (v)
	Esp.NamesColor = v
 end)

 ESPSection:CreateToggle("Enable Names Outline", {Toggled=configs.ESPNamesOutline , Description = false}, function(Value)
	configs.ESPNamesOutline = Value
	Esp.NamesOutline = Value
 end)

 ESPSection:CreateSlider("Name Font", {Min = 1, Max = 10, DefaultValue = 2}, function(Value)
	Esp.NamesFont = Value
 end)

 ESPSection:CreateSlider("Name Size", {Min = 5, Max = 30, DefaultValue = 13}, function(Value)
	Esp.NamesSize = Value
 end)


 PlrSection:CreateToggle("No Clip", {Toggled=configs.NoClip , Description = false}, function(s)
	configs.NoClip = s
	getgenv().Noclip = s
	game:GetService("RunService").Heartbeat:Connect(function()
		if Noclip == true then
			game:GetService("RunService").Stepped:wait()
			game.Players.LocalPlayer.Character.Head.CanCollide = false
			game.Players.LocalPlayer.Character.Torso.CanCollide = false
		end
	end)
 end)

getgenv().autorespawn = false 

function autorespawn()
	while getgenv().autorespawn == true do 
 local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

if Workspace.CurrentCamera.CameraType == Enum.CameraType.Scriptable then
   require(ReplicatedStorage.Loader).ServerEvent("Core", "LoadCharacter", {})
   require(ReplicatedStorage.Loader).ServerEvent("Main", "LoadCharacter")
   local Clone = Workspace.CurrentCamera:Clone()
   Workspace.CurrentCamera:Destroy()
   Clone.CameraType = Enum.CameraType.Custom
   Clone.CameraSubject = Players.LocalPlayer.Character
   Clone.Parent = Workspace
   Players.LocalPlayer.PlayerGui.UI.MainMenu.Visible = false
   Players.LocalPlayer.PlayerGui.UI.HUD.Visible = true
end
task.wait()
break
end 
return
end 

PlrSection:CreateToggle("Auto Respawn", {Toggled=configs.AutoRespawn , Description = false}, function(bool)
	configs.AutoRespawn = bool
	getgenv().autorespawn = bool 
	while bool do 
		task.wait()
		autorespawn()
	end 
 end)


 PlrSection:CreateToggle("Infinite Jump", {Toggled=configs.InfiniteJump , Description = false}, function(s)
	configs.InfiniteJump = s
	getgenv().InfJ = s
	game:GetService("UserInputService").JumpRequest:connect(function()
		if InfJ == true then
			game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")
		end
	end)
 end)

 

 PlrSection:CreateSlider("Field of View", {Min = 10, Max = 120, DefaultValue = 70}, function(v)
	game.Workspace.CurrentCamera.FieldOfView = v
 end)

 CreditsSection:CreateButton("Founders: kyograve, edizfather", function ()
	print("hi!")
 end)

 CreditsSection:CreateButton("Main Developer: kyograve", function ()
	print("hi!")
 end)

 CreditsSection:CreateButton("Copy Discord Invite!", function ()
	setclipboard("https://discord.gg/NcdHwy8Td6")
	print("https://discord.gg/NcdHwy8Td6")
 end)

 AntiSection:CreateToggle("Safezone God", {Toggled=configs.SafeZoneGod , Description = false}, function(bool)
	getgenv().safezonegod = bool 
	configs.SafeZoneGod = bool
	while bool do 
		task.wait()
		safezonegod()
	end
 end)
getgenv().safezonegod = false 
 function safezonegod()
	while getgenv().safezonegod == true do 
		-- Server-side script (e.g., in ServerScriptService)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Replicator = ReplicatedStorage:WaitForChild("Replicator")

Replicator.OnServerInvoke = function(player, action, parameters)
    -- Check if the action is "SetSafeZone" (you can use any criteria)
    if action == "SetSafeZone" then
        print(player.Name .. " set a safe zone.")
local v1 = "Core"
local v2 = "SetSafeZone"
local v3 = {
}
local event = game:GetService("ReplicatedStorage").Replicator
event:InvokeServer(v1, v2, v3)
        
        return "Safe zone set successfully"
    else
        return "Invalid action"
    end
end
task.wait()
local v1 = "Core"
local v2 = "SetSafeZone"
local v3 = {
}
local event = game:GetService("ReplicatedStorage").Replicator

event:InvokeServer(v1, v2, v3)
end 
end 





 local mt = getrawmetatable(game)

 local oldindex = mt.__index
 setreadonly(mt, false)
 mt.__index = newcclosure(function(self, method)
 
 if method == 'JumpPower' then
   return 50
 end

 
 return oldindex(self, method)
 end)
 setreadonly(mt, true)


 getgenv().walkspeedenabled = false 
spawn(function()
	function walkspeedenabled()
		if getgenv().walkspeedenabled == true then 
local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local W, A, S, D
local xVelo, yVelo

RS.RenderStepped:Connect(function()
   local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart
   local C = game.Workspace.CurrentCamera
   local LV = C.CFrame.LookVector
   for i,v in pairs(UIS:GetKeysPressed()) do
       if v.KeyCode == Enum.KeyCode.W then
           W = true
       end
       if v.KeyCode == Enum.KeyCode.A then
           A = true
       end
       if v.KeyCode == Enum.KeyCode.S then
           S = true
       end
       if v.KeyCode == Enum.KeyCode.D then
           D = true
       end
   end

   if W == true and S == true then
       yVelo = false
       W,S = nil
   end

   if A == true and D == true then
       xVelo = false
       A,D = nil
   end

   if yVelo ~= false then
       if W == true then
           if xVelo ~= false then
               if A == true then
                   local LeftLV = (C.CFrame * CFrame.Angles(0, math.rad(45), 0)).LookVector
                   HRP.Velocity = Vector3.new((LeftLV.X * walkSpeed), HRP.Velocity.Y, (LeftLV.Z * walkSpeed))
                   W,A = nil
               else
                   if D == true then
                       local RightLV = (C.CFrame * CFrame.Angles(0, math.rad(-45), 0)).LookVector
                       HRP.Velocity = Vector3.new((RightLV.X * walkSpeed), HRP.Velocity.Y, (RightLV.Z * walkSpeed))
                       W,D = nil
                   end
               end
           end
       else
           if S == true then
               if xVelo ~= false then
                   if A == true then
                       local LeftLV = (C.CFrame * CFrame.Angles(0, math.rad(135), 0)).LookVector
                       HRP.Velocity = Vector3.new((LeftLV.X * walkSpeed), HRP.Velocity.Y, (LeftLV.Z * walkSpeed))
                       S,A = nil
                   else
                       if D == true then
                           local RightLV = (C.CFrame * CFrame.Angles(0, math.rad(-135), 0)).LookVector
                           HRP.Velocity = Vector3.new((RightLV.X * walkSpeed), HRP.Velocity.Y, (RightLV.Z * walkSpeed))
                           S,D = nil
                       end
                   end
               end
           end
       end
   end

   if W == true then
       HRP.Velocity = Vector3.new((LV.X * walkSpeed), HRP.Velocity.Y, (LV.Z * walkSpeed))
   end
   if S == true then
       HRP.Velocity = Vector3.new(-(LV.X * walkSpeed), HRP.Velocity.Y, -(LV.Z * walkSpeed))
   end
   if A == true then
       local LeftLV = (C.CFrame * CFrame.Angles(0, math.rad(90), 0)).LookVector
       HRP.Velocity = Vector3.new((LeftLV.X * walkSpeed), HRP.Velocity.Y, (LeftLV.Z * walkSpeed))
   end
   if D == true then
       local RightLV = (C.CFrame * CFrame.Angles(0, math.rad(-90), 0)).LookVector
       HRP.Velocity = Vector3.new((RightLV.X * walkSpeed), HRP.Velocity.Y, (RightLV.Z * walkSpeed))
   end

   xVelo, yVelo, W, A, S, D = nil
end)
task.wait()
end 
end 
end)



 PlrSection:CreateToggle("WalkSpeed Enabled", {Toggled=configs.WalkSpeedEnabled , Description = "Want to enable the Walk Speed?"}, function(v)
	getgenv().walkspeedenabled = v 
	configs.WalkSpeedEnabled = v
	if v == true then 
		task.wait()
		walkspeedenabled(walkSpeed)
	elseif v == false then
		walkSpeed = 16
	end
 end)

 PlrSection:CreateSlider("Walk Speed", {Min = 16, Max = 500, DefaultValue = 16}, function(v)
	walkSpeed = v
 end)

 PlrSection:CreateSlider("Jump Power", {Min = 50, Max = 500, DefaultValue = 50}, function(v)
	game.Players.LocalPlayer.Character.Humanoid.JumpPower = v
 end)


 local playerDropdown = nil
 local playerOptions = {}
 
 local selectedPlayer = nil
 local isSpectating = false
 
 local function updateDropdown()
	 playerOptions = {}
	 for _, player in pairs(game.Players:GetPlayers()) do
		 table.insert(playerOptions, player.Name)
	 end
	 if playerDropdown then
		 playerDropdown:Clear()
		 playerDropdown:Add(playerOptions)
	 end
 end
 
 playerDropdown = BountySection2:CreateDropdown("Select Player", {
	 List = playerOptions,
	 Default = "None"
 }, function(value)
	 selectedPlayer = value
 end)
 
 local notificationSent = false  -- Add this variable

 local function spectatePlayer()
	 if isSpectating then
		 local playerToSpectate = game.Players[selectedPlayer]
		 if playerToSpectate and playerToSpectate.Character and playerToSpectate.Character:FindFirstChild("HumanoidRootPart") then
			 game.Workspace.CurrentCamera.CameraSubject = playerToSpectate.Character:FindFirstChild("HumanoidRootPart")
			 if not notificationSent then  -- Check if a notification has been sent
				 notifications:message{
					 Title = "Kaos Hub",
					 Description = "Spectating: [ " .. selectedPlayer .. " ]",
					 Accept = {
						 Text = "Okay",
					 }
				 }
				 notificationSent = true  -- Set the variable to true to indicate a notification has been sent
			 end
		 else
			 isSpectating = false
			 if not notificationSent then
				 notifications:message{
					 Title = "Error!",
					 Description = "Can't spectate the Player anymore: [ " .. selectedPlayer .. " ]",
					 Accept = {
						 Text = "Okay",
					 }
				 }
				 notificationSent = true
			 end
			 game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
		 end
	 else
		 notificationSent = false  -- Reset the notificationSent variable when not spectating
	 end
 end
 
 local spectateToggle = BountySection2:CreateToggle("Spectate", { Toggled = false, Description = false }, function(Value)
    isSpectating = Value
    if not Value then
        -- If the toggle is turned off, stop spectating
        isSpectating = false
        game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
    end
    spectatePlayer()
end)

 
 -- Listen for player added and removed events to keep the dropdown list updated
 game.Players.PlayerAdded:Connect(updateDropdown)
 game.Players.PlayerRemoving:Connect(function(player)
	 for i, playerName in pairs(playerOptions) do
		 if playerName == player.Name then
			 table.remove(playerOptions, i)
		 end
	 end
 end)
 
 -- Create a button to manually refresh the dropdown
 BountySection2:CreateButton("Refresh List", function()
	 updateDropdown()
 end)
 
 -- Use a Heartbeat connection to continuously update the camera subject
 local heartbeatConnection
 heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
	 spectatePlayer()
 end)
-------------------------------------------------------------------------------------------------------------------

local selecteddistancesr
local virtualUser = game:GetService('VirtualUser')
local Mobsoulreaper

-- Get the folder containing the mobs (replace with the actual path)
local mobFolder = game:GetService("Workspace").Characters.NPCs  

-- Create a table to store mob names
local mobNames = {}

-- Get the children (mobs) of the folder
local mobs = mobFolder:GetChildren()

for _, mob in ipairs(mobs) do
    if mob:IsA("Model") then 
        table.insert(mobNames, mob.Name)
    end
end

local selectedMob = ""  -- Initialize with an empty string
local selectedBoss = ""  -- Initialize with an empty string

local MainSection = Main:CreateSection("Farming")

MainSection:CreateDropdown("Method", {
    List = {"Behind", "Below", "Upper"},
    Default = "None"
}, function(value)
	configs.Method = value
    _G.Method4 = value
end)

spawn(function()
    while wait() do 
        pcall(function()
            if _G.Method4 == "Behind" then
                MethodKill2 = CFrame.new(0, 0, selecteddistancesr)
            elseif _G.Method4 == "Below" then
                MethodKill2 = CFrame.new(0, -selecteddistancesr, 0)
            elseif _G.Method4 == "Upper" then
                MethodKill2 = CFrame.new(0, selecteddistancesr, 0)
            else
                _G.Method4 = CFrame.new(0, 0, selecteddistancesr)
            end
        end)
    end
end)

selecteddistancesr = 1
MainSection:CreateSlider("Distance", {Min = 1, Max = 15, DefaultValue = 6}, function(v)
	configs.DistanceAutoFarm = v
    selecteddistancesr = v 
end)

MainSection:CreateDropdown("Select Mobs", {
    List = mobNames,
    Default = "None"
}, function(vmob)
	configs.SelectedMob = vmob 
    selectedMob = vmob
end)

-- Add a Dropdown for Boss selection
MainSection:CreateDropdown("Select Bosses", {
    List = {"Marco", "Kaido"}, -- Replace with actual boss names
    Default = "None"
}, function(vboss)
	configs.SelectedBoss = vboss
    selectedBoss = vboss
end)

local movingToMob = false  -- Flag to prevent overlapping movements
local safePlaceEnabled = false  

MainSection:CreateToggle("Auto Farm", {Toggled=configs.AutoFarm , Description = false}, function(Value)
    getgenv().autofarmsoulreaper = Value
	configs.AutoFarm = Value
    while Value do
        wait()
        if not movingToMob and not safePlaceEnabled then
            moveToMob(selectedMob)
        end
    end
end)



MainSection:CreateToggle("Safe Mode", {Toggled=configs.SafeMode , Description = "Teleports you Away if Health below 30%"}, function(bool)
	configs.SafeMode = bool
    safePlaceEnabled = bool
end)

function moveToMob(selectedMob)
    local player = game.Players.LocalPlayer
    local character = player.Character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")

    while getgenv().autofarmsoulreaper do
        pcall(function()
            for i, v in pairs(game:GetService("Workspace").Characters.NPCs:GetChildren()) do 
                if v:IsA("Model") and v.Name == selectedMob then
                    if v.Humanoid.Health > 0 and character.Humanoid.Health > 0 then
                        movingToMob = true
                        local mobRootPart = v:FindFirstChild("HumanoidRootPart")
                        if mobRootPart then
                            humanoidRootPart.CFrame = mobRootPart.CFrame * MethodKill2
                        end
                        movingToMob = false
                    end
                end
            end
            return
        end)
        wait()
    end
end

function checkHealth()
    if safePlaceEnabled then
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid.Health / humanoid.MaxHealth < 0.4 then
                local currentPosition = player.Character.PrimaryPart.Position
                local teleportLocation = CFrame.new(currentPosition.x, currentPosition.y + 300, currentPosition.z)
                player.Character:SetPrimaryPartCFrame(teleportLocation)
            end
        end
    end
end

while true do
    wait(.2)
    checkHealth()
end
